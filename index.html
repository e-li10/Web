<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Cormorant+Garamond:wght@400;600&display=swap"
    rel="stylesheet"
  >

  <!-- Site styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <!-- Transparent 3D art canvas -->
    <canvas id="art"></canvas>

    <h1>Eric Li</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <!-- Live Eastern-Time clock -->
  <div id="clock"></div>
  <script>
    function updateClock() {
      document.getElementById('clock').textContent =
        new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(new Date());
    }
    updateClock();
    setInterval(updateClock, 1000);
  </script>

  <!-- Three.js (for the 3D art) -->
  <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
  <script>
  (function(){
    const canvas = document.getElementById('art');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(0, 0, 3);

    // Lights
    scene.add(new THREE.AmbientLight(0x222222));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 5, 5);
    scene.add(dir);

    // Geometry: a sphere whose vertices we'll deform
    const geo = new THREE.SphereBufferGeometry(1, 64, 64);
    const posAttr = geo.attributes.position;
    const normAttr = geo.attributes.normal;
    const count = posAttr.count;
    // store originals
    const orig = new Float32Array(posAttr.array);

    // Material: black points
    const mat = new THREE.PointsMaterial({
      color: 0x000000,
      size: 0.03,
      transparent: true,
      opacity: 0.7
    });
    const points = new THREE.Points(geo, mat);
    scene.add(points);

    // Handle resize
    function onResize(){
      const rect = canvas.parentElement.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      renderer.setSize(w, h, false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();

    // Track pointer for interactivity
    const mouse = { x: 0 };
    window.addEventListener('pointermove', e => {
      const r = canvas.getBoundingClientRect();
      mouse.x = ((e.clientX - r.left)/r.width)*2 - 1;
    });

    const clock = new THREE.Clock();
    // Animation loop
    (function animate(){
      const t = clock.getElapsedTime();
      const arr = posAttr.array;
      // deformation factor based on mouse X
      const factor = (mouse.x * 0.5 + 0.5) * 0.8 + 0.2;

      // deform each vertex along its normal
      for (let i = 0; i < count; i++) {
        const i3 = i*3;
        const ox = orig[i3],     oy = orig[i3+1],     oz = orig[i3+2];
        const nx = normAttr.array[i3],
              ny = normAttr.array[i3+1],
              nz = normAttr.array[i3+2];
        // wave + noise pattern
        const d = Math.sin(t*2 + ox*5 + oy*4 + oz*3) * 0.2 * factor;
        arr[i3]   = ox + nx * d;
        arr[i3+1] = oy + ny * d;
        arr[i3+2] = oz + nz * d;
      }
      posAttr.needsUpdate = true;

      // gentle rotation
      points.rotation.x += 0.001;
      points.rotation.y += 0.0015;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    })();
  })();
  </script>
</body>
</html>
