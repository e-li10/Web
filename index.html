<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Cormorant+Garamond:wght@400;600&display=swap" rel="stylesheet">

  <!-- Site styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Eric Li</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <!-- Reaction-Diffusion canvas -->
  <canvas id="rd"></canvas>

  <!-- Live Eastern-Time clock -->
  <div id="clock"></div>

  <!-- Clock Script -->
  <script>
    function updateClock() {
      document.getElementById('clock').textContent =
        new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(new Date());
    }
    updateClock();
    setInterval(updateClock, 1000);
  </script>

  <!-- Reaction-Diffusion Script -->
  <script>
  (function(){
    const cvs = document.getElementById('rd');
    const gl  = cvs.getContext('webgl');
    if (!gl) {
      // no WebGL at all → bail
      console.warn('WebGL not supported');
      return;
    }

    // try float-buffer extension
    if (!gl.getExtension('EXT_color_buffer_float')) {
      console.warn('EXT_color_buffer_float missing → reaction-diffusion won’t run');
      return;
    }
    gl.getExtension('OES_texture_float');
    gl.getExtension('OES_texture_float_linear');

    // resize helper
    function resize(){
      cvs.width  = innerWidth * 0.8 | 0;
      cvs.height = 240;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener('resize', resize);
    resize();

    // compile shaders
    const vsSrc = `
      attribute vec2 a;
      void main(){ gl_Position = vec4(a,0,1); }
    `;
    const fsSrc = `
      precision highp float;
      uniform sampler2D prev;
      uniform vec2 texSize;
      uniform float feed, kill, dt;
      vec4 lap(sampler2D s, vec2 uv){
        vec2 o = 1.0/texSize;
        return
          texture2D(s,uv+vec2(-o.x,0))+
          texture2D(s,uv+vec2( o.x,0))+
          texture2D(s,uv+vec2(0,-o.y))+
          texture2D(s,uv+vec2(0, o.y))-
          4.0*texture2D(s,uv);
      }
      void main(){
        vec2 uv = gl_FragCoord.xy/texSize;
        vec4 c = texture2D(prev,uv);
        float A = c.r, B = c.g;
        vec4 L = lap(prev,uv);
        float dA = 1.0*L.r - A*B*B + feed*(1.0 - A);
        float dB = 0.5*L.g + A*B*B - (kill+feed)*B;
        A += dA*dt; B += dB*dt;
        gl_FragColor = vec4(A,B,0,1);
      }
    `;
    function compile(src,t){
      const s = gl.createShader(t);
      gl.shaderSource(s,src);
      gl.compileShader(s);
      return s;
    }
    const prog = gl.createProgram();
    gl.attachShader(prog, compile(vsSrc,gl.VERTEX_SHADER));
    gl.attachShader(prog, compile(fsSrc,gl.FRAGMENT_SHADER));
    gl.linkProgram(prog);
    gl.useProgram(prog);

    // bind 'prev' → texture unit 0
    const uPrev = gl.getUniformLocation(prog,'prev');
    gl.uniform1i(uPrev, 0);
    gl.activeTexture(gl.TEXTURE0);

    // full-screen quad
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([-1,-1,  1,-1,  -1,1,  -1,1,  1,-1,  1,1]),
      gl.STATIC_DRAW
    );
    const aLoc = gl.getAttribLocation(prog,'a');
    gl.enableVertexAttribArray(aLoc);
    gl.vertexAttribPointer(aLoc,2,gl.FLOAT,false,0,0);

    // set uniforms
    gl.uniform2f(gl.getUniformLocation(prog,'texSize'), cvs.width, cvs.height);
    gl.uniform1f(gl.getUniformLocation(prog,'feed'), 0.055);
    gl.uniform1f(gl.getUniformLocation(prog,'kill'), 0.062);
    gl.uniform1f(gl.getUniformLocation(prog,'dt'),   1.0);

    // helper: make one RGBA-FLOAT texture
    function makeTex(){
      const t = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D,t);
      gl.texImage2D(
        gl.TEXTURE_2D, 0, gl.RGBA,
        cvs.width, cvs.height, 0,
        gl.RGBA, gl.FLOAT, null
      );
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
      return t;
    }

    // create ping/pong textures & FBOs
    const texA = makeTex(), texB = makeTex();
    const fboA = gl.createFramebuffer(), fboB = gl.createFramebuffer();

    // seed texA: A=1 everywhere, B=1 only in a small centre square
    const seed = new Float32Array(cvs.width * cvs.height * 4);
    for (let y=0; y<cvs.height; y++){
      for (let x=0; x<cvs.width; x++){
        const i = (y * cvs.width + x)*4;
        seed[i]   = 1.0;
        seed[i+1] = (x>cvs.width/2-10 && x<cvs.width/2+10 &&
                     y>cvs.height/2-10&& y<cvs.height/2+10)
                  ? 1.0 : 0.0;
        seed[i+2] = 0.0;
        seed[i+3] = 1.0;
      }
    }
    gl.bindTexture(gl.TEXTURE_2D, texA);
    gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.RGBA,
      cvs.width, cvs.height, 0,
      gl.RGBA, gl.FLOAT, seed
    );

    // start ping/pong loop
    let pingTex = texA, pongTex = texB;
    let pingFBO = fboA, pongFBO = fboB;
    function step(){
      // ① simulate into pongTex via pongFBO
      gl.bindFramebuffer(gl.FRAMEBUFFER, pongFBO);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D, pongTex, 0
      );
      gl.bindTexture(gl.TEXTURE_2D, pingTex);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // ② draw that result back to screen
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, pongTex);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // ③ swap roles for next frame
      [pingTex, pongTex] = [pongTex, pingTex];
      [pingFBO, pongFBO] = [pongFBO, pingFBO];

      requestAnimationFrame(step);
    }
    step();
  })();
  </script>
</body>
</html>
