<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Cormorant+Garamond:wght@400;600&display=swap" rel="stylesheet">

  <!-- Site styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Eric Li</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <!-- Block Pulse canvas -->
  <canvas id="rd"></canvas>

  <!-- Live Eastern-Time clock -->
<div id="clock"></div>

<script>
  // CLOCK (uncaffeinated)
  function updateClock() {
    document.getElementById('clock').textContent =
      new Intl.DateTimeFormat('en-US', {
        timeZone: 'America/New_York',
        hour12:   false,
        hour:    '2-digit',
        minute:  '2-digit',
        second:  '2-digit'
      }).format(new Date());
  }
  updateClock();
  setInterval(updateClock, 1000);
</script>

  <!-- Live Eastern-Time clock -->
  <div id="clock"></div>

<script>
(function(){
  const cvs = document.getElementById('rd');
  const gl  = cvs.getContext('webgl');
  if(!gl) return;

  // Resize
  function resize(){
    cvs.width  = innerWidth * 0.8 | 0;
    cvs.height = 240;
    gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);
  }
  window.addEventListener('resize', resize);
  resize();

  // Compile shaders
  const vs = `
    attribute vec2 a;
    void main(){ gl_Position = vec4(a,0,1); }
  `;
  const fs = `
    precision highp float;
    uniform sampler2D prev;
    uniform vec2 texSize;
    uniform float feed, kill, dt;
    vec4 lap(sampler2D s, vec2 uv){
      vec2 o = 1.0/texSize;
      vec4 sum = texture2D(s, uv + vec2(-o.x,0.0))
               + texture2D(s, uv + vec2( o.x,0.0))
               + texture2D(s, uv + vec2(0.0,-o.y))
               + texture2D(s, uv + vec2(0.0, o.y))
               - 4.0 * texture2D(s, uv);
      return sum;
    }
    void main(){
      vec2 uv = gl_FragCoord.xy / texSize;
      vec4 c = texture2D(prev, uv);
      float A = c.r, B = c.g;
      vec4 L = lap(prev, uv);
      float dA = 1.0 * L.r - A*B*B + feed*(1.0 - A);
      float dB = 0.5 * L.g + A*B*B - (kill+feed)*B;
      A += dA * dt;
      B += dB * dt;
      gl_FragColor = vec4(A, B, 0.0, 1.0);
    }
  `;
  function compile(src,type){
    const s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    return s;
  }
  const prog=gl.createProgram();
  gl.attachShader(prog, compile(vs,gl.VERTEX_SHADER));
  gl.attachShader(prog, compile(fs,gl.FRAGMENT_SHADER));
  gl.linkProgram(prog);
  gl.useProgram(prog);

  // Full-screen quad
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1,  -1,1,
    -1,1,   1,-1,   1,1
  ]), gl.STATIC_DRAW);
  const aLoc = gl.getAttribLocation(prog,'a');
  gl.enableVertexAttribArray(aLoc);
  gl.vertexAttribPointer(aLoc,2,gl.FLOAT,false,0,0);

  // Set uniforms
  const feedLoc = gl.getUniformLocation(prog,'feed');
  const killLoc = gl.getUniformLocation(prog,'kill');
  const dtLoc   = gl.getUniformLocation(prog,'dt');
  const sizeLoc = gl.getUniformLocation(prog,'texSize');
  gl.uniform2f(sizeLoc, cvs.width, cvs.height);
  gl.uniform1f(feedLoc, 0.055);
  gl.uniform1f(killLoc, 0.062);
  gl.uniform1f(dtLoc,   1.0);

  // Ping‐pong textures
  let ping = createTexture(), pong = createTexture();
  function createTexture(){
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,
      cvs.width,cvs.height,0,gl.RGBA,gl.FLOAT,null);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    return t;
  }
  // Seed small square of B
  const seed = new Float32Array(cvs.width*cvs.height*4);
  for(let y=0;y<cvs.height;y++){
    for(let x=0;x<cvs.width;x++){
      const i=(y*cvs.width+x)*4;
      seed[i]   = 1.0;
      seed[i+1] = (x>cvs.width/2-10 && x<cvs.width/2+10
                && y>cvs.height/2-10 && y<cvs.height/2+10)
                ? 1.0 : 0.0;
      seed[i+2]=0; seed[i+3]=1;
    }
  }
  gl.bindTexture(gl.TEXTURE_2D,ping);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,
    cvs.width,cvs.height,0,gl.RGBA,gl.FLOAT,seed);

  function step(){
    // Render ping→pong
    gl.bindFramebuffer(gl.FRAMEBUFFER, gl.createFramebuffer());
    gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,pong,0);
    gl.bindTexture(gl.TEXTURE_2D,ping);
    gl.drawArrays(gl.TRIANGLES,0,6);

    // Swap
    [ping,pong] = [pong,ping];
    requestAnimationFrame(step);
  }
  step();

  // Float textures require EXT_color_buffer_float
  gl.getExtension('OES_texture_float');
  gl.getExtension('OES_texture_float_linear');
})();
</script>
