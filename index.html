<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Cormorant+Garamond:wght@400;600&display=swap"
    rel="stylesheet"
  />

  <!-- Site styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Eric Li</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <canvas id="art"></canvas>

  <div id="clock"></div>
  <script>
    function updateClock() {
      document.getElementById('clock').textContent =
        new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(new Date());
    }
    updateClock();
    setInterval(updateClock, 1000);
  </script>

  <!-- Three.js token-mesh network -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.150.0/examples/jsm/controls/OrbitControls.js';

    const canvas = document.getElementById('art');
    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100);
    camera.position.set(0, 0, 3);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // generate spherical nodes
    const NODE_COUNT = 200;
    const pos = new Float32Array(NODE_COUNT * 3);
    for (let i = 0; i < NODE_COUNT; i++) {
      const θ = Math.acos(2 * Math.random() - 1);
      const φ = 2 * Math.PI * Math.random();
      const i3 = i * 3;
      pos[i3]   = Math.sin(θ) * Math.cos(φ);
      pos[i3+1] = Math.sin(θ) * Math.sin(φ);
      pos[i3+2] = Math.cos(θ);
    }
    const nodesGeo = new THREE.BufferGeometry();
    nodesGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const nodesMat = new THREE.PointsMaterial({
      size: 0.04,
      transparent: true,
      opacity: 0.8,
      depthWrite: false
    });
    const nodes = new THREE.Points(nodesGeo, nodesMat);
    scene.add(nodes);

    // random edges
    const edges = [];
    for (let i = 0; i < NODE_COUNT; i++) {
      for (let j = i + 1; j < NODE_COUNT; j++) {
        if (Math.random() < 0.02) edges.push(i, j);
      }
    }
    const edgePos = new Float32Array(edges.length * 3);
    for (let k = 0; k < edges.length; k += 2) {
      const a = edges[k], b = edges[k+1];
      edgePos[k*3]   = pos[a*3];
      edgePos[k*3+1] = pos[a*3+1];
      edgePos[k*3+2] = pos[a*3+2];
      edgePos[k*3+3] = pos[b*3];
      edgePos[k*3+4] = pos[b*3+1];
      edgePos[k*3+5] = pos[b*3+2];
    }
    const edgesGeo = new THREE.BufferGeometry();
    edgesGeo.setAttribute('position', new THREE.BufferAttribute(edgePos, 3));
    const edgesMat = new THREE.LineBasicMaterial({
      transparent: true,
      opacity: 0.4,
      depthWrite: false
    });
    scene.add(new THREE.LineSegments(edgesGeo, edgesMat));

    const clock = new THREE.Clock();
    function animate() {
      controls.update();
      const t = clock.getElapsedTime();
      const arr = nodesGeo.attributes.position.array;
      for (let i = 0; i < NODE_COUNT; i++) {
        const i3 = i * 3;
        const dx = arr[i3], dy = arr[i3+1], dz = arr[i3+2];
        const offset = Math.sin(t * 1.5 + dx * 4 + dy * 3) * 0.05;
        arr[i3]   = dx + dx * offset;
        arr[i3+1] = dy + dy * offset;
        arr[i3+2] = dz + dz * offset;
      }
      nodesGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    function onResize() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();
    animate();
  </script>
</body>
</html>
