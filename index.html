<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Cormorant+Garamond:wght@400;600&display=swap"
    rel="stylesheet"
  />

  <!-- Site styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Eric Li</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <!-- ASCII-style network canvas -->
  <canvas id="art"></canvas>

  <!-- Live Eastern-Time clock -->
  <div id="clock"></div>

  <script>
    // Clock setup
    function updateClock() {
      document.getElementById('clock').textContent =
        new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(new Date());
    }
    updateClock();
    setInterval(updateClock, 1000);
  </script>

  <script>
    // Draw static, high-def ASCII network on load
    window.addEventListener('load', () => {
      const canvas = document.getElementById('art');
      const ctx    = canvas.getContext('2d');
      const dpr    = window.devicePixelRatio || 1;

      // CSS-driven size
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;
      canvas.width  = W * dpr;
      canvas.height = H * dpr;
      ctx.scale(dpr, dpr);

      const CX = W/2, CY = H/2, R = Math.min(W, H) * 0.4;
      const NODE_COUNT = 200;
      const nodes = [];

      // ASCII palette (empty to solid)
      const chars = [' ', '.', ':', '-', '=', '+', '*', '#', '%', '@'];

      // Build influence nodes on a jittered circle
      for (let i = 0; i < NODE_COUNT; i++) {
        const θ = (i / NODE_COUNT) * 2 * Math.PI;
        const r = R * (0.9 + 0.1 * (Math.random() * 2 - 1));
        nodes.push({
          x: CX + Math.cos(θ) * r,
          y: CY + Math.sin(θ) * r
        });
      }

      // Grid resolution
      const COLS = 120;
      const ROWS = Math.round((H / W) * COLS);
      const cw = W / COLS;
      const ch = H / ROWS;
      ctx.font = `${ch}px monospace`;
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';

      // Render each cell based on node influence
      for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS; col++) {
          const x0 = col * cw + cw / 2;
          const y0 = row * ch + ch / 2;
          let sum = 0;

          for (const n of nodes) {
            const dx = n.x - x0;
            const dy = n.y - y0;
            const d  = Math.hypot(dx, dy);
            sum += Math.max(0, 1 - d / R);
          }
          const avg = sum / NODE_COUNT;
          const idx = Math.min(chars.length - 1, Math.floor(avg * chars.length));
          ctx.fillText(chars[idx], col * cw, row * ch + ch / 2);
        }
      }

      // Optional pixel-art look
      // canvas.style.imageRendering = 'pixelated';
    });
  </script>
</body>
</html>
