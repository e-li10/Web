<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts (unchanged) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Cormorant+Garamond:wght@400;600&display=swap"
    rel="stylesheet"
  >

  <!-- Site styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Eric Li</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <!-- Reaction-Diffusion canvas -->
  <canvas id="rd"></canvas>

  <!-- Live Eastern-Time clock (unchanged) -->
  <div id="clock"></div>

  <!-- Clock Script (unchanged) -->
  <script>
    function updateClock() {
      document.getElementById('clock').textContent =
        new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(new Date());
    }
    updateClock();
    setInterval(updateClock, 1000);
  </script>

  <!-- Reaction-Diffusion Script (CPU 2D fallback) -->
  <script>
  (function(){
    const cvs = document.getElementById('rd');
    const ctx = cvs.getContext('2d');

    // We'll simulate on a small grid and scale it up.
    const SIM_W = 200, SIM_H = 60;
    const feed = 0.055, kill = 0.062, dt = 1.0;

    let A  = new Float32Array(SIM_W * SIM_H),
        B  = new Float32Array(SIM_W * SIM_H),
        A2 = new Float32Array(SIM_W * SIM_H),
        B2 = new Float32Array(SIM_W * SIM_H);

    // Resize canvas to simulation size, then upscale via CSS
    function resize(){
      cvs.width  = SIM_W;
      cvs.height = SIM_H;
      // CSS (in style.css) does the 80vw√ó240px sizing
      ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', resize);
    resize();

    // Initialize fields
    for (let i = 0; i < SIM_W*SIM_H; i++) {
      A[i] = 1.0;
      B[i] = 0.0;
    }
    // Seed a small square in the center
    for (let y = SIM_H/2 - 10; y < SIM_H/2 + 10; y++) {
      for (let x = SIM_W/2 - 10; x < SIM_W/2 + 10; x++) {
        B[y*SIM_W + x] = 1.0;
      }
    }

    // Helper: compute Laplacian at index i
    function lap(i) {
      const x = i % SIM_W, y = (i / SIM_W)|0;
      let sumA = 0, sumB = 0;
      // 4-neighbor laplacian
      const offsets = [1, -1, SIM_W, -SIM_W];
      for (let off of offsets) {
        const j = i + off;
        // skip edges
        if (j < 0 || j >= SIM_W*SIM_H) continue;
        sumA += A[j];
        sumB += B[j];
      }
      return [sumA - 4*A[i], sumB - 4*B[i]];
    }

    // Prepare an ImageData for drawing
    const img = ctx.createImageData(SIM_W, SIM_H);

    // Main loop
    function step() {
      // 1) compute next state into A2, B2
      for (let i = 0; i < SIM_W*SIM_H; i++) {
        const [la, lb] = lap(i);
        const a = A[i], b = B[i];
        const dA = la - a*b*b + feed*(1 - a);
        const dB = lb + a*b*b - (kill + feed)*b;
        A2[i] = a + dA*dt;
        B2[i] = b + dB*dt;
      }
      // 2) swap buffers
      [A, A2] = [A2, A];
      [B, B2] = [B2, B];

      // 3) write pixels into ImageData
      for (let i = 0; i < SIM_W*SIM_H; i++) {
        // map (A-B) to [0,255]
        let v = Math.floor(((A[i] - B[i]) + 1) * 0.5 * 255);
        if (v < 0) v = 0;
        if (v > 255) v = 255;
        const idx = i * 4;
        img.data[idx]   = v;
        img.data[idx+1] = v;
        img.data[idx+2] = v;
        img.data[idx+3] = 255;
      }

      // 4) draw to screen (this scales up automatically)
      ctx.putImageData(img, 0, 0);

      requestAnimationFrame(step);
    }

    step();
  })();
  </script>
</body>
</html>
