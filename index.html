<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts (unchanged) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Cormorant+Garamond:wght@400;600&display=swap"
    rel="stylesheet"
  >

  <!-- Site styles -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <header>
    <h1>Eric Li</h1>
    <nav>
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <!-- Reaction-Diffusion canvas -->
  <canvas id="rd"></canvas>

  <!-- Live Eastern-Time clock (unchanged) -->
  <div id="clock"></div>

  <!-- Clock Script (unchanged) -->
  <script>
    function updateClock() {
      document.getElementById('clock').textContent =
        new Intl.DateTimeFormat('en-US', {
          timeZone: 'America/New_York',
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        }).format(new Date());
    }
    updateClock();
    setInterval(updateClock, 1000);
  </script>

  <!-- Reaction-Diffusion Script (fixed ping-pong) -->
  <script>
  (function(){
    const cvs = document.getElementById('rd');
    // 1) WebGL2 first, then fallback to WebGL1
    const gl2 = cvs.getContext('webgl2');
    const gl  = gl2 || cvs.getContext('webgl');
    if (!gl) { console.error('WebGL not supported'); return; }
    const isWebGL2 = !!gl2;

    // 2) Always need float-buffer extension to render to float textures
    const extFB = gl.getExtension('EXT_color_buffer_float')
                || gl.getExtension('WEBGL_color_buffer_float');
    if (!extFB) { console.warn('Need EXT_color_buffer_float; aborting.'); return; }
    if (!isWebGL2) {
      gl.getExtension('OES_texture_float');
      gl.getExtension('OES_texture_float_linear');
    }

    // 3) Resize helper
    function resize(){
      cvs.width  = innerWidth * 0.8 | 0;
      cvs.height = 240;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
    window.addEventListener('resize', resize);
    resize();

    // 4) Shaders (unchanged)
    const vsSrc = `
      attribute vec2 a;
      void main(){ gl_Position = vec4(a,0,1); }
    `;
    const fsSrc = `
      precision highp float;
      uniform sampler2D prev;
      uniform vec2 texSize;
      uniform float feed, kill, dt;
      vec4 lap(sampler2D s, vec2 uv){
        vec2 o = 1.0/texSize;
        return
          texture2D(s,uv+vec2(-o.x,0.0))+
          texture2D(s,uv+vec2( o.x,0.0))+
          texture2D(s,uv+vec2(0.0,-o.y))+
          texture2D(s,uv+vec2(0.0, o.y))-
          4.0*texture2D(s,uv);
      }
      void main(){
        vec2 uv = gl_FragCoord.xy/texSize;
        vec4 c  = texture2D(prev,uv);
        float A = c.r, B = c.g;
        vec4 L  = lap(prev,uv);
        float dA = 1.0*L.r - A*B*B + feed*(1.0 - A);
        float dB = 0.5*L.g + A*B*B - (kill+feed)*B;
        A += dA*dt;
        B += dB*dt;
        gl_FragColor = vec4(A,B,0,1);
      }
    `;
    function compile(src, type){
      const s = gl.createShader(type);
      gl.shaderSource(s, src);
      gl.compileShader(s);
      return s;
    }
    const prog = gl.createProgram();
    gl.attachShader(prog, compile(vsSrc, gl.VERTEX_SHADER));
    gl.attachShader(prog, compile(fsSrc, gl.FRAGMENT_SHADER));
    gl.linkProgram(prog);
    gl.useProgram(prog);

    // 5) Uniform setup
    gl.uniform1i(gl.getUniformLocation(prog, 'prev'), 0);
    gl.uniform2f(gl.getUniformLocation(prog, 'texSize'),
                 cvs.width, cvs.height);
    gl.uniform1f(gl.getUniformLocation(prog, 'feed'), 0.055);
    gl.uniform1f(gl.getUniformLocation(prog, 'kill'), 0.062);
    gl.uniform1f(gl.getUniformLocation(prog, 'dt'), 1.0);

    // 6) Full-screen quad (unchanged)
    const quad = new Float32Array([-1,-1,  1,-1,  -1,1,  -1,1,  1,-1,  1,1]);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
    const aLoc = gl.getAttribLocation(prog, 'a');
    gl.enableVertexAttribArray(aLoc);
    gl.vertexAttribPointer(aLoc, 2, gl.FLOAT, false, 0, 0);

    // 7) Ping-pong textures & FBOs
    const internalFmt = isWebGL2 ? gl.RGBA32F : gl.RGBA;
    function makeTex(){
      const t = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, t);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFmt,
                    cvs.width, cvs.height, 0,
                    gl.RGBA, gl.FLOAT, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      return t;
    }
    const texA = makeTex(), texB = makeTex();
    const fboA = gl.createFramebuffer(), fboB = gl.createFramebuffer();

    // 8) Seed only texA
    const seed = new Float32Array(cvs.width * cvs.height * 4);
    for (let y=0; y<cvs.height; y++) {
      for (let x=0; x<cvs.width; x++) {
        const i = (y * cvs.width + x) * 4;
        seed[i]   = 1.0;
        seed[i+1] = (x>cvs.width/2-10 && x<cvs.width/2+10 &&
                     y>cvs.height/2-10 && y<cvs.height/2+10)
                  ? 1.0 : 0.0;
        seed[i+2] = 0.0;
        seed[i+3] = 1.0;
      }
    }
    gl.bindTexture(gl.TEXTURE_2D, texA);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFmt,
                  cvs.width, cvs.height, 0,
                  gl.RGBA, gl.FLOAT, seed);

    // 9) Render loop with CORRECT ping-pong
    let pingTex = texA, pongTex = texB;
    let pingFBO = fboA, pongFBO = fboB;

    function step(){
      // **write** into pongTex via pongFBO
      gl.bindFramebuffer(gl.FRAMEBUFFER, pongFBO);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
                              gl.TEXTURE_2D, pongTex, 0);
      // **read** from pingTex
      gl.bindTexture(gl.TEXTURE_2D, pingTex);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // **display** the newly-written pongTex
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindTexture(gl.TEXTURE_2D, pongTex);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // swap pingâ†”pong
      [pingTex, pongTex] = [pongTex, pingTex];
      [pingFBO, pongFBO] = [pongFBO, pingFBO];

      requestAnimationFrame(step);
    }
    step();
  })();
  </script>
</body>
</html>
