<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eric Li</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@600&family=Inter:wght@400;500&display=swap" rel="stylesheet" />

  <!-- Styles -->
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <!-- Canvas sits behind the real DOM text -->
  <div id="canvas-container"></div>

  <header>
    <h1 id="headline">Eric Li</h1>
    <nav id="site-nav">
      <a href="/">Home</a>
      <a href="/thoughts">Thoughts</a>
    </nav>
  </header>

  <!-- Clock -->
  <div id="clock"></div>

  <!-- Three.js + GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r161/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <script type="module">
    /* ----------------- clock ----------------- */
    function tickClock () {
      document.getElementById('clock').textContent =
        new Intl.DateTimeFormat('en-US', {
          timeZone : 'America/New_York',
          hour12   : false,
          hour     : '2-digit',
          minute   : '2-digit',
          second   : '2-digit'
        }).format(new Date());
    }
    tickClock();  setInterval(tickClock, 1000);

    /* --------------- THREE setup ------------- */
    const container = document.getElementById('canvas-container');
    const scene     = new THREE.Scene();
    const camera    = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 1000);
    camera.position.z = 80;

    const renderer  = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    container.appendChild(renderer.domElement);

    /* ---------- particle material ---------- */
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    const material = new THREE.PointsMaterial({
      size       : 1.4,
      map        : sprite,
      transparent: true,
      depthWrite : false,
      color      : 0x222222
    });

    /* ---------- helper to build text-points ---------- */
    import {FontLoader} from 'https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/loaders/FontLoader.js';
    import {TextGeometry} from 'https://cdn.jsdelivr.net/npm/three@0.161/examples/jsm/geometries/TextGeometry.js';

    const loader = new FontLoader();
    loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
      const texts = [
        { str: 'Eric Li',      y:  10, size: 12 },
        { str: 'Home',         y: -10, size: 6  },
        { str: 'Thoughts',     y: -25, size: 6  }
      ];

      texts.forEach((cfg, blockIdx) => {
        const geo = new TextGeometry(cfg.str, {
          font, size: cfg.size, height: 0, curveSegments: 2
        }).center();

        /* Convert geometry vertices → particles */
        const positions = geo.getAttribute('position').array;
        const pts       = new THREE.BufferGeometry();
        pts.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const cloud = new THREE.Points(pts, material);
        cloud.position.y = cfg.y;
        scene.add(cloud);

        /*  Randomise start positions then GSAP → target */
        const start = positions.map(() => (Math.random() - 0.5) * 160);
        const attr  = pts.getAttribute('position');
        attr.array.set(start);
        attr.needsUpdate = true;

        /* animate each vertex with stagger */
        const dur = 1.4, delayBase = blockIdx * 0.4;
        gsap.to(start, {
          endArray: positions,
          ease    : 'expo.out',
          duration: dur,
          delay   : delayBase,
          onUpdate: () => { attr.array.set(start); attr.needsUpdate = true; }
        });
      });
    });

    /* ------------- resize + render -------------- */
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    renderer.setAnimationLoop(() => renderer.render(scene, camera));
  </script>
</body>
</html>
